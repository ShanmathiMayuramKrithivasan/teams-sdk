"use strict";(self.webpackChunkteams_md=self.webpackChunkteams_md||[]).push([[3384],{21341:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/stateful-chat-example-503f5e716853958efa6f8c4537b5e193.png"},26802:(e,n,t)=>{t.d(n,{A:()=>a});var s=t(22147),i=t(62540);function a({language:e,children:n}){return(0,s.zy)().pathname.includes(`/${e}/`)?(0,i.jsx)(i.Fragment,{children:n}):null}},43023:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(63696);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}},84103:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"csharp/in-depth-guides/ai/keeping-state","title":"Keeping State","description":"\x3c!--","source":"@site/docs/main/csharp/in-depth-guides/ai/keeping-state.mdx","sourceDirName":"csharp/in-depth-guides/ai","slug":"/csharp/in-depth-guides/ai/keeping-state","permalink":"/teams-sdk/csharp/in-depth-guides/ai/keeping-state","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/teams-sdk/tree/main/teams.md/docs/main/csharp/in-depth-guides/ai/keeping-state.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Keeping State","title":"Keeping State","summary":"Guide to managing conversation state in LLM interactions, explaining how to maintain chat history using ChatPrompt\'s state management capabilities and implementing custom persistence strategies for multi-conversation scenarios."},"sidebar":"default","previous":{"title":"Function Calling","permalink":"/teams-sdk/csharp/in-depth-guides/ai/function-calling"},"next":{"title":"Best Practices","permalink":"/teams-sdk/csharp/in-depth-guides/ai/best-practices"}}');var i=t(62540),a=t(43023),o=t(26802);const r={sidebar_position:4,sidebar_label:"Keeping State",title:"Keeping State",summary:"Guide to managing conversation state in LLM interactions, explaining how to maintain chat history using ChatPrompt's state management capabilities and implementing custom persistence strategies for multi-conversation scenarios."},c="Keeping State",l={},d=[{value:"State Initialization",id:"state-initialization",level:2},{value:"Usage Example",id:"usage-example",level:2},{value:"Usage in your application",id:"usage-in-your-application",level:3},{value:"How It Works",id:"how-it-works",level:4}];function p(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"keeping-state",children:"Keeping State"})}),"\n",(0,i.jsx)(n.p,{children:"By default, LLMs are not stateful. This means that they do not remember previous messages or context when generating a response.\nIt's common practice to keep state of the conversation history in your application and pass it to the LLM each time you make a request."}),"\n",(0,i.jsxs)(n.p,{children:["By default, the ",(0,i.jsx)(n.code,{children:"ChatPrompt"})," instance will create a temporary in-memory store to keep track of the conversation history. This is beneficial\nwhen you want to use it to generate an LLM response, but not persist the conversation history. But in other cases, you may want to keep the conversation history"]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["By reusing the same ",(0,i.jsx)(n.code,{children:"ChatPrompt"})," class instance across multiple conversations will lead to the conversation history being shared across all conversations. Which is usually not the desired behavior."]})}),"\n",(0,i.jsxs)(n.p,{children:["To avoid this, you need to get messages from your persistent (or in-memory) store and pass it in to the ",(0,i.jsx)(n.code,{children:"ChatPrompt"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ChatPrompt"})," class will modify the messages object that's passed into it. So if you want to manually manage it, you need to make a copy of the messages object before passing it in."]})}),"\n",(0,i.jsx)(n.h2,{id:"state-initialization",children:"State Initialization"}),"\n",(0,i.jsx)(n.p,{children:"Here's how to initialize and manage conversation state for multiple conversations:"}),"\n",(0,i.jsx)(o.A,{language:"csharp",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"using Microsoft.Teams.AI;\nusing Microsoft.Teams.AI.Messages;\nusing Microsoft.Teams.AI.Models.OpenAI;\nusing Microsoft.Teams.AI.Prompts;\nusing Microsoft.Teams.AI.Templates;\nusing Microsoft.Teams.Api.Activities;\nusing Microsoft.Teams.Apps;\n\n// Simple in-memory store for conversation histories\n// In your application, it may be a good idea to use a more\n// persistent store backed by a database or other storage solution\nprivate static readonly Dictionary<string, List<IMessage>> ConversationStore = new();\n\n/// <summary>\n/// Get or create conversation memory for a specific conversation\n/// </summary>\npublic static List<IMessage> GetOrCreateConversationMemory(string conversationId)\n{\n    if (!ConversationStore.ContainsKey(conversationId))\n    {\n        ConversationStore[conversationId] = new List<IMessage>();\n    }\n\n    return ConversationStore[conversationId];\n}\n\n/// <summary>\n/// Clear memory for a specific conversation\n/// </summary>\npublic static Task ClearConversationMemory(string conversationId)\n{\n    if (ConversationStore.TryGetValue(conversationId, out var messages))\n    {\n        var messageCount = messages.Count;\n        messages.Clear();\n    }\n\n    return Task.CompletedTask;\n}\n"})})}),"\n",(0,i.jsx)(n.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,i.jsx)(o.A,{language:"csharp",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'/// <summary>\n/// Example of stateful conversation handler that maintains conversation history\n/// </summary>\npublic static async Task HandleStatefulConversation(OpenAIChatModel model, IContext<MessageActivity> context)\n{\n    // Retrieve existing conversation memory or initialize new one\n    var messages = GetOrCreateConversationMemory(context.Activity.Conversation.Id);\n\n    // Create prompt with conversation-specific memory\n    var prompt = new OpenAIChatPrompt(model, new ChatPromptOptions\n    {\n        Instructions = new StringTemplate("You are a helpful assistant that remembers our previous conversation.")\n    });\n\n    // Send with existing messages as context\n    var options = new IChatPrompt<OpenAI.Chat.ChatCompletionOptions>.RequestOptions\n    {\n        Messages = messages\n    };\n    var result = await prompt.Send(context.Activity.Text, options);\n\n    if (result.Content != null)\n    {\n        var message = new MessageActivity\n        {\n            Text = result.Content,\n        }.AddAIGenerated();\n        await context.Send(message);\n\n        // Update conversation history\n        messages.Add(UserMessage.Text(context.Activity.Text));\n        messages.Add(new ModelMessage<string>(result.Content));\n    }\n    else\n    {\n        await context.Reply("I did not generate a response.");\n    }\n}\n'})})}),"\n",(0,i.jsxs)(o.A,{language:"csharp",children:[(0,i.jsx)(n.h3,{id:"usage-in-your-application",children:"Usage in your application"}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:"teamsApp.OnMessage(async (context) =>\n{\n    await HandleStatefulConversation(aiModel, context);\n});\n"})}),(0,i.jsx)(n.h4,{id:"how-it-works",children:"How It Works"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conversation Store"}),": A dictionary maps conversation IDs to their message histories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Per-Conversation Memory"}),": Each conversation gets its own isolated message list"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Request Options"}),": Pass the message history via ",(0,i.jsx)(n.code,{children:"RequestOptions.Messages"})," when calling ",(0,i.jsx)(n.code,{children:"Send()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Updates"}),": After receiving a response, manually add both the user message and AI response to the store"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Persistence"}),": The conversation history persists across multiple user interactions within the same conversation"]}),"\n"]}),(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ChatPrompt.Send()"})," method does ",(0,i.jsx)(n.strong,{children:"not"})," automatically update the messages you pass in via ",(0,i.jsx)(n.code,{children:"RequestOptions"}),". You must manually add the user message and AI response to your conversation store after each interaction."]})}),(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"In a production application, consider using a more robust storage solution like Azure Cosmos DB, SQL Server, or Redis instead of an in-memory dictionary. This ensures conversation history persists across application restarts and scales across multiple instances."})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Stateful Chat Example",src:t(21341).A+"",width:"1588",height:"1162"})})]})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);
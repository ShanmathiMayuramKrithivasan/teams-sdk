"use strict";(self.webpackChunkteams_md=self.webpackChunkteams_md||[]).push([[6628],{21341:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/stateful-chat-example-503f5e716853958efa6f8c4537b5e193.png"},26802:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(22147),s=n(62540);function a({language:e,children:t}){return(0,i.zy)().pathname.includes(`/${e}/`)?(0,s.jsx)(s.Fragment,{children:t}):null}},43023:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(63696);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}},86336:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"python/in-depth-guides/ai/keeping-state","title":"Keeping State","description":"\x3c!--","source":"@site/docs/main/python/in-depth-guides/ai/keeping-state.mdx","sourceDirName":"python/in-depth-guides/ai","slug":"/python/in-depth-guides/ai/keeping-state","permalink":"/teams-sdk/python/in-depth-guides/ai/keeping-state","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/teams-sdk/tree/main/teams.md/docs/main/python/in-depth-guides/ai/keeping-state.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"sidebar_label":"Keeping State","title":"Keeping State","summary":"Guide to managing conversation state in LLM interactions, explaining how to maintain chat history using ChatPrompt\'s state management capabilities and implementing custom persistence strategies for multi-conversation scenarios."},"sidebar":"default","previous":{"title":"Function Calling","permalink":"/teams-sdk/python/in-depth-guides/ai/function-calling"},"next":{"title":"Best Practices","permalink":"/teams-sdk/python/in-depth-guides/ai/best-practices"}}');var s=n(62540),a=n(43023),o=n(26802);const r={sidebar_position:4,sidebar_label:"Keeping State",title:"Keeping State",summary:"Guide to managing conversation state in LLM interactions, explaining how to maintain chat history using ChatPrompt's state management capabilities and implementing custom persistence strategies for multi-conversation scenarios."},c="Keeping State",m={},l=[{value:"State Initialization",id:"state-initialization",level:2},{value:"Usage Example",id:"usage-example",level:2}];function d(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"keeping-state",children:"Keeping State"})}),"\n",(0,s.jsx)(t.p,{children:"By default, LLMs are not stateful. This means that they do not remember previous messages or context when generating a response.\nIt's common practice to keep state of the conversation history in your application and pass it to the LLM each time you make a request."}),"\n",(0,s.jsxs)(t.p,{children:["By default, the ",(0,s.jsx)(t.code,{children:"ChatPrompt"})," instance will create a temporary in-memory store to keep track of the conversation history. This is beneficial\nwhen you want to use it to generate an LLM response, but not persist the conversation history. But in other cases, you may want to keep the conversation history"]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["By reusing the same ",(0,s.jsx)(t.code,{children:"ChatPrompt"})," class instance across multiple conversations will lead to the conversation history being shared across all conversations. Which is usually not the desired behavior."]})}),"\n",(0,s.jsxs)(t.p,{children:["To avoid this, you need to get messages from your persistent (or in-memory) store and pass it in to the ",(0,s.jsx)(t.code,{children:"ChatPrompt"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"ChatPrompt"})," class will modify the messages object that's passed into it. So if you want to manually manage it, you need to make a copy of the messages object before passing it in."]})}),"\n",(0,s.jsx)(t.h2,{id:"state-initialization",children:"State Initialization"}),"\n",(0,s.jsx)(t.p,{children:"Here's how to initialize and manage conversation state for multiple conversations:"}),"\n",(0,s.jsx)(o.A,{language:"python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from microsoft_teams.ai import ChatPrompt, ListMemory, AIModel\nfrom microsoft_teams.openai import OpenAICompletionsAIModel\n\n# Simple in-memory store for conversation histories\n# In your application, it may be a good idea to use a more\n# persistent store backed by a database or other storage solution\nconversation_store: dict[str, ListMemory] = {}\n\n# Initialize AI model\nai_model = OpenAICompletionsAIModel(model="gpt-4")\n\ndef get_or_create_conversation_memory(conversation_id: str) -> ListMemory:\n    """Get or create conversation memory for a specific conversation"""\n    if conversation_id not in conversation_store:\n        conversation_store[conversation_id] = ListMemory()\n    return conversation_store[conversation_id]\n\nasync def clear_conversation_memory(conversation_id: str) -> None:\n    """Clear memory for a specific conversation"""\n    if conversation_id in conversation_store:\n        memory = conversation_store[conversation_id]\n        await memory.set_all([])\n        print(f"Cleared memory for conversation {conversation_id}")\n'})})}),"\n",(0,s.jsx)(t.h2,{id:"usage-example",children:"Usage Example"}),"\n",(0,s.jsx)(o.A,{language:"python",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from microsoft_teams.ai import ChatPrompt, ListMemory, AIModel\nfrom microsoft_teams.api import MessageActivity, MessageActivityInput\nfrom microsoft_teams.apps import ActivityContext\n# ...\n\nasync def handle_stateful_conversation(model: AIModel, ctx: ActivityContext[MessageActivity]) -> None:\n    """Example of stateful conversation handler that maintains conversation history"""\n    print(f"Received message: {ctx.activity.text}")\n\n    # Retrieve existing conversation memory or initialize new one\n    memory = get_or_create_conversation_memory(ctx.activity.conversation.id)\n\n    # Get existing messages for logging\n    existing_messages = await memory.get_all()\n    print(f"Existing messages before sending to prompt: {len(existing_messages)} messages")\n\n    # Create ChatPrompt with conversation-specific memory\n    chat_prompt = ChatPrompt(model, memory=memory)\n\n    chat_result = await chat_prompt.send(\n        input=ctx.activity.text,\n        instructions="You are a helpful assistant that remembers our previous conversation."\n    )\n\n    if chat_result.response.content:\n        message = MessageActivityInput(text=chat_result.response.content).add_ai_generated()\n        await ctx.send(message)\n    else:\n        await ctx.reply("I did not generate a response.")\n\n    # Log final message count\n    final_messages = await memory.get_all()\n    print(f"Messages after sending to prompt: {len(final_messages)} messages")\n\n@app.on_message\nasync def handle_message(ctx: ActivityContext[MessageActivity]):\n    """Handle messages using stateful conversation"""\n    await handle_stateful_conversation(ai_model, ctx)\n'})})}),"\n",(0,s.jsx)(o.A,{language:"python",children:(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Screenshot of chat between user and agent, user first states &#39;My dinosaur&#39;s name is Barnie&#39; and later asks What&#39;s my pet&#39;s name and the agent responds correctly with &#39;Barnie&#39;.",src:n(21341).A+"",width:"1588",height:"1162"})})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);